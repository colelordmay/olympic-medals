<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>

<style>
.tooltip {
  position: absolute;
  text-align: left;
  padding: 6px;
  font: 12px sans-serif;
  background: white;
  border: 1px solid #999;
  border-radius: 4px;
  pointer-events: none;
  opacity: 0;
}
</style>

<div id="container" style="position: relative;">
  <svg id="my_dataviz" width="800" height="600">
    <defs>
      <pattern id="hashPattern" patternUnits="userSpaceOnUse" width="6" height="6" patternTransform="rotate(45)">
        <rect width="6" height="6" fill="lightgrey"></rect>
        <line x1="0" y="0" x2="0" y2="6" stroke="grey" stroke-width="1"/>
      </pattern>
    </defs>
  </svg>
  <div class="tooltip" id="tooltip"></div>
</div>

<script>

// The svg
const svg = d3.select("svg"),
  width = +svg.attr("width"),
  height = +svg.attr("height");

// Create the tooltip div
const tooltip = d3.select("#tooltip");

// Map projection
const projection = d3.geoMercator()
  .scale(100)
  .center([0, 20])
  .translate([width / 2, height / 2]);

const path = d3.geoPath().projection(projection);

// Data map
const data = new Map();

// Wes Anderson inspired red to blue diverging interpolator
// function wesAndersonInterpolator(t) {
//   // You can adjust these colors to taste. Here's a warm red (#D94F4F) to cool blue (#4F7BD9)
//   const red = d3.rgb("#D94F4F");
//   const blue = d3.rgb("#4F7BD9");
//   return d3.interpolateRgb(red, blue)(t);
// }

function wesAndersonInterpolator(t) {
  // Define color stops (Wes Anderson inspired red to green)
  const colors = [
    d3.rgb("#D94F4F"),  // warm red
    d3.rgb("#E6C85A"),  // mustard yellow
    d3.rgb("#A3B368"),  // olive green
    d3.rgb("#476A34")   // forest green (dark)
  ];

  // Map t [0,1] to these segments
  if (t < 0.33) {
    // interpolate red to yellow
    return d3.interpolateRgb(colors[0], colors[1])(t / 0.33);
  } else if (t < 0.66) {
    // interpolate yellow to olive
    return d3.interpolateRgb(colors[1], colors[2])((t - 0.33) / 0.33);
  } else {
    // interpolate olive to dark green
    return d3.interpolateRgb(colors[2], colors[3])((t - 0.66) / 0.34);
  }
}


// Color scale domain and range
const minVal = 5_000_000;
const maxVal = 200_000_000;

const colorScale = d3.scaleDiverging()
  .domain([minVal, (minVal + maxVal) / 2, maxVal])
  .interpolator(wesAndersonInterpolator)
  .clamp(true);

let currentZoom = 1;  // track current zoom level

// Load data and draw map
Promise.all([
  d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"),
  d3.csv("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv", function(d) {
    data.set(d.code, +d.pop);
  })
]).then(function(loadData) {
  let topo = loadData[0];

  // Group for zoom
  const g = svg.append("g");

  // Mouse event handlers
  let mouseOver = function(event, d) {
    d3.selectAll(".Country")
      .transition()
      .duration(200)
      .style("opacity", 0.5);

    d3.select(this)
      .interrupt()
      .transition()
      .duration(200)
      .style("opacity", 1)
      .style("stroke", "black")
      .style("stroke-width", `${2 / currentZoom}px`);

    tooltip
      .style("opacity", 1)
      .html(`<strong>${d.properties.name}</strong><br>population = ${d.total.toLocaleString()}`);
  };

  let mouseMove = function(event, d) {
    tooltip
      .style("left", (event.pageX + 10) + "px")
      .style("top", (event.pageY + 10) + "px");
  };

  let mouseLeave = function(event, d) {
    d3.selectAll(".Country")
      .interrupt()
      .style("opacity", 0.8);

    d3.select(this)
      .interrupt()
      .style("stroke", "transparent")
      .style("stroke-width", `${1 / currentZoom}px`);

    tooltip
      .style("opacity", 0);
  };

  // Draw map
  g.selectAll("path")
    .data(topo.features)
    .enter()
    .append("path")
      .attr("d", path)
      .attr("fill", function(d) {
        d.total = data.get(d.id) || 0;

        if (d.total < 1_000_000) {
          // Below threshold: hashed grey fill
          return "url(#hashPattern)";
        }
        else {
          // Clamp data to min/max by colorScale.clamp(true)
          return colorScale(d.total);
        }
      })
      .style("stroke", "transparent")
      .attr("class", "Country")
      .style("opacity", 0.8)
      .on("mouseover", mouseOver)
      .on("mousemove", mouseMove)
      .on("mouseleave", mouseLeave);

  // Zoom behavior
  const zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", function(event) {
      const { transform } = event;

      currentZoom = transform.k;

      g.attr("transform", transform);

      g.selectAll(".Country")
        .style("stroke-width", `${1 / currentZoom}px`);
    });

  svg.call(zoom);

  // Initial stroke width
  g.selectAll(".Country")
    .style("stroke-width", "1px");
});

</script>
